import errno
import os
import pynetlinux
import socket
import sys
import select
import threading
import tweetnacl as nacl


class Tunnel(threading.Thread):
    # Initialise NaClShuttle.
    def __init__(self, taddr, tmask, tmtu, laddr, lport, remote_address, remote_port):
        super(Tunnel, self).__init__()
        self._tap = pynetlinux.tap.Tap()
        self._tap.set_ip(taddr)
        self._tap.set_netmask(int(tmask))
        self._tmtu = tmtu
        self._tap.up()
        self._sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self._sock.bind((laddr, lport))
        self._remote_address = remote_address
        self._remote_port = remote_port

    def run(self):
        mtu = self._tmtu
        files = [self._tap, self._sock]
        to_tap = None
        to_sock = None
        tap = os.open("/dev/net/tun", os.O_RDWR | os.O_NONBLOCK)
        while True:
            try:
                r, w, x = select.select(files, files, [])
                if self._tap in r:
                    # Read packet generated by client on the TAP.
                    to_sock = self._tap.read(mtu)

                # Server receives packet from client.
                if self._sock in r:
                    # Read packet from socket. addr[0] is the remote ip
                    # and addr[1] is the remote port.
                    to_tap, addr = self._sock.recvfrom(65535)

                    # Decryption of packets read from the socket.
                    key = 'ThisKeyIsNotSoSecretThisKeyIsNot'
                    nonce = 'NonceNonceNonceNonceNonc'
                    to_tap_decrypted = nacl.crypto_secretbox_open(to_tap, nonce, key)

                    to_tap = to_tap_decrypted

                # Send packet (back) to client
                if to_tap and self._tap in w:
                    # Begin write section of main loop. Only control packets and
                    # packets received from socket should be processed here.
                    self._tap.write(to_tap)
                    to_tap = None

                if to_sock and self._sock in w:
                    # Packets read in from the TAP are written to the socket as
                    # bytes. The socket.sendto() function encapsulates the
                    # payload with the appropriate Ethernet/IP/UDP headers.

                    # Encryption of packets written to the socket.
                    key = 'ThisKeyIsNotSoSecretThisKeyIsNot'
                    nonce = 'NonceNonceNonceNonceNonc'
                    to_sock_encrypted = nacl.crypto_secretbox(to_sock, nonce, key)

                    to_sock = to_sock_encrypted

                    self._sock.sendto(
                        to_sock, (self._remote_address, self._remote_port))
                    to_sock = None
            except (select.error, socket.error) as e:
                if e[0] == errno.EINTR:
                    continue
                sys.stderr.write(str(e))
                break
            except KeyboardInterrupt:
                # When Ctrl + C is pressed, remove ^C and show message.
                print u'\u0008\u0008NaClShuttle: Closed.'
                sys.exit(0)
